Description: Symlinks and large trash cans
 Symlinks to other partitions should not be followed.
 Also the applet dies when dealing with large trash cans.
 This commit is deals with the initial issues and adds
 pointers where further work needs to take place in slow time
Author: David Mohammed <fossfreedom@ubuntu.com>
Bug-Ubuntu: https://launchpad.net/bugs/1872197
Last-Update: 2020-04-11

--- budgie-extras-0.10.1.orig/budgie-trash/src/helpers/TrashHelper.vala
+++ budgie-extras-0.10.1/budgie-trash/src/helpers/TrashHelper.vala
@@ -75,6 +75,7 @@ public class TrashHelper {
 
         // Reading original Path and DeletionDate data
         // Restoring file
+        // Needs more work to deal with other partition trash cans
         if(infoFile.query_exists()){
 
             infoFile.read_async.begin(Priority.DEFAULT, null, (obj, res) => {
@@ -162,6 +163,11 @@ public class TrashHelper {
         if(trashFile.query_exists()){
             try{
                 FileEnumerator enumerator = trashFile.enumerate_children("standard::*", FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null);
+                /***
+                * a bit arbitary - but only load the first 20 files from the trash can
+                * otherwise in large trash cans we'll run out of file-handles - this needs rework
+                ****/
+                int loop = 0;
                 while(true){
                     FileInfo fileInfo = enumerator.next_file(null);
                     if(fileInfo != null){
@@ -170,6 +176,10 @@ public class TrashHelper {
                         CustomFile customFile = new CustomFile(childFile, fileInfo);
 
                         fileInfos.append(customFile);
+                        loop++;
+                        if (loop >= 20) {
+                            break;
+                        }
                     }else{
                         break;
                     }
@@ -207,6 +217,10 @@ public class TrashHelper {
 
     //[empty START]
     public void emptyTrash(){
+        /***
+        * need to use threads here otherwise large deletes will lockup the user interface
+        ***/
+
         updateIndicatorIcon(TRASH_DELETING);
         emptyTrashInfoFile();
         emptyTrashFilesFile();
@@ -226,7 +240,7 @@ public class TrashHelper {
                     }
                 }
             }catch(GLib.Error e){
-                print ("Error: %s\n", e.message);
+                print ("emptyTrashInfoFile Error: %s\n", e.message);
             }
         }
     }
@@ -242,8 +256,16 @@ public class TrashHelper {
                     if(fileInfo != null){
 
                         GLib.File childFile = trashFile.get_child(fileInfo.get_name());
-                        moveFileToCacheThenDelete(childFile, fileInfo.get_name());
-
+                        if (fileInfo.get_is_symlink()) {
+                            try {
+                                childFile.delete(null);
+                            } catch (GLib.Error e) {
+                                print ("delete symlink Error: %s\n", e.message);
+                            }
+                        }
+                        else {
+                            moveFileToCacheThenDelete(childFile, fileInfo.get_name());
+                        }
                     }else{
                         updateIndicatorIcon(TRASH_EMPTY);
                         break;
@@ -251,7 +273,7 @@ public class TrashHelper {
                 }
 
             }catch(GLib.Error e){
-                print ("Error: %s\n", e.message);
+                print ("emptyTrashFilesFile Error: %s\n", e.message);
             }
         }
     }
@@ -259,7 +281,7 @@ public class TrashHelper {
     public void deleteFile(GLib.File file, bool deleteDirectory){
         try{
             updateIndicatorIcon(TRASH_DELETING);
-            GLib.FileType fileType = file.query_file_type (GLib.FileQueryInfoFlags.NONE, null);
+            GLib.FileType fileType = file.query_file_type (GLib.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null);
             if(fileType == GLib.FileType.DIRECTORY) {
                 deleteDirectoryContent(file, deleteDirectory);
             }else{
@@ -267,7 +289,7 @@ public class TrashHelper {
                 updateIndicatorIcon(TRASH_EMPTY);
             }
         }catch(GLib.Error e){
-            print ("Error: %s\n", e.message);
+            print ("deleteFile Error: %s\n", e.message);
         }
     }
 
@@ -288,7 +310,7 @@ public class TrashHelper {
                 }
             }
         }catch(GLib.Error e){
-            print ("Error: %s\n", e.message);
+            print ("deleteDirectoryContent Error: %s\n", e.message);
         }
 
     }
@@ -304,7 +326,7 @@ public class TrashHelper {
                     return true;
                 }
             }catch(GLib.Error e){
-                print ("Error: %s\n", e.message);
+                print ("isTrashEmpty Error: %s\n", e.message);
                 return true;
             }
         }else{
@@ -313,9 +335,14 @@ public class TrashHelper {
     }
 
     public void moveFileToCacheThenDelete(GLib.File src, string fileName){
+
         if(src.query_exists()){
             try{
-
+                /***
+                * This needs rework since it only handles the default trash can
+                * every partition can have a trash can - thus the move
+                * bit add the end turns into a copy which fails
+                ***/
                 string homePath = Environment.get_home_dir();
                 string destPath = homePath + "/.cache/budgie-trash/" + fileName;
                 string destParentPath = homePath + "/.cache/budgie-trash/";
@@ -330,7 +357,7 @@ public class TrashHelper {
                 src.move(dest, FileCopyFlags.NONE, null);
                 deleteFile(dest, true);
             } catch (Error e) {
-                print ("Error: %s\n", e.message);
+                print ("moveFileToCacheThenDelete Error: %s\n", e.message);
             }
         }
     }
